# java第四次作业
项目构建使用`maven`，里面使用了`profile`，根据`os.name`来下载对应平台的`lwjgl`包，包括`windows,linux,macos`，命令行运行：
```shell
mvn compile
mvn exec:java
```
主要做的工作将实例代码里面的一些功能集成到自己的游戏里面，由于之前我的游戏实现的东西有点多了，所以在`recording`上做了一些比较大的改动。
首先游戏逻辑比较简单，有一个玩家由用户进行操作，可以使用方向键或者`asdw`来进行方向的移动，按下空格来进行攻击（也就是发射子弹），通过鼠标来控制
视角，见第三次作业的`readme`以及第四次作业的视频演示。

关键帧中只保留一些动态的游戏对象的信息，包括位置，渲染组件等等。在游戏回放的过程中，使用的是两个关键帧信息中游戏对象来进行插值来进行平滑过渡，
但是如果直接套用示例代码里面的逻辑，则有很大的问题。首先，示例代码里面关键帧插值是针对一种对象不会消失的特殊场景，实例里面虽然`AIPlayer`的数量
会随时间不断增加，但是每个对象在`GameLogic`里面的`gameobjects`的`List`里面的索引是不会变的，因为没有将对象动态进行删除的现象（Player发生碰撞
之后直接GameOver了），所以游戏对象只增不减，所以在相邻两个关键帧进行的插值中，只需要取两个关键帧里面entities的大小最小者每个索引一一对应即可，
即关键帧的更新逻辑是比较简单。但是我自己的游戏里面，涉及游戏对象的销毁，需要将对象从`Scene`里面移除，所以相邻关键帧里面的对象其实是无法根据索引值来
进行一一对应的。解决的办法是将游戏对象使用支持键值对查找的数据结构，比如`Map`，我这里使用基于平衡树的`TreeMap`，可以将关键帧里面的`id`设置为
随对象而异的字符串，比如`obj1,obj2,...,objxxx`，这样的话需要修改关键帧写入的相关函数，而关键帧转json的过程中，`id`属性是通过`getName()`
方法来获取的，所以涉及子类里面`getName`方法的重写，根据比较麻烦，所以为了简单起见，在一些子类里面（会动态变化的对象，比如玩家），新增一个整型
的ID，ID分配在父类里面进行，这样所有子类在需要ID的时候，在父类的构造函数里面就已经分配好了，不需要在子类构造函数或者工厂方法里面显式分配，
每次增加一个动态游戏对象，分配一次ID，目前不打算管理可用ID，因为感觉不太可能会耗尽32位整数，然后我们在关键帧里面增加一个整型的属性即可。

检测对象销毁也很简单，首先将`Map`里面的对象都标记为`no Active`，然后遍历两个相邻的关键帧，将关键帧里面存在的对象再标记为`Active`，最后在update
的时候移除不活跃的对象即可。

渲染后端的适配

主要是做图片绘制的设配，之前都是基于`swing`框架的，里面在绘制图片的时候，可以直接使用`BufferedImage`来进行绘制，但是使用了`GPU`，没有图片这个
概念，只有一个在显存里面的一个Texture采样，所以需要改变一些接口。重新定义一个基类，比如`MyImage`，派生出来两个子类`CPUImage和GPUTexture`，
两个子类分别用于不同的渲染后端`CPURenderer和GPURenderer`，两个后端分别独立实现`IRenderer`接口，然后`IRenderer`里面通过`MyImage`来进行绘制即可。

在`GPU`渲染器端实现一个图片绘制的功能也简单，绘制两个三角形然后绑定纹理到槽位上，设置四个顶点的纹理uv采样坐标即可，如果使用`lwjgl`就是一个API的事情，
甚至不需要写shader，还是比原生`C/C++`调用`OpenGL`还要简单，
还有就是`GLFW`包里面的一些逻辑在实例代码里面没有完全处理好，比如点击窗口的关闭图标，我在windows上发现程序会卡死，原因是`glfw`里面已销毁窗口了，
但是实例代码里面没有添加对应的`clean`动作来销毁游戏引擎，因为实例代码里面主要还是通过游戏自然结束和用户按键来响应的，如果用户随便乱点，有些逻辑
忘了处理，那么就会出现卡死或者窗口销毁了但是程序还在后台跑。我尝试修复一下，但是后面加入录制服务之后需要考虑的东西比较多，现在就先让游戏自动结束，
然后用户通过`esc`等按键来进行交互，等后面如果有时间再来修复。。。

[视频演示](https://www.bilibili.com/video/BV1VECKB2EWZ)